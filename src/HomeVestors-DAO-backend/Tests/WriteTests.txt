0 make sure you create a property with any / all relevant fields already created for testing
First add to testOption the enum your testing
Second add the new test cases in create test options, which involves adding the type to TestOptions and determining the specific scenarios your testing for for example noteCreate
Third in TestCases.createWhat create the function that creates the relevant args for each of your test types, having a generic arg builder helps here
Fourth in expected Outcomes module in createExpectedOutcome function create the functions that return the expected results from calling the function
5 if testing a entirely new main struct within property add it to formatMismatchedSectionsExpected function
Thats it!

Old:
func createNoteExpectedOutcome(tcase: NoteCreateCase): UpdateResult {
        let prop = Prop.createBlankProperty();
        switch(tcase){
            case (#AnonymousAuthor) return #Err([(?0, #InvalidData{field= "author"; reason = #Anonymous;})]);
            case(#EmptyTitle) return #Err([(?0, #InvalidData{field = "title"; reason = #EmptyString;})]);
            case(#EmptyContent) return #Err([(?0, #InvalidData{field = "content"; reason = #EmptyString;})]);
            case(#FutureDate) return #Err([(?0, #InvalidData({ field = "Upload Date"; reason = #CannotBeSetInTheFuture }))]);
            case(_) {
                let arg = TestCases.createNoteTestCaseArg(tcase);
                let note = Prop.validNote(1, arg);
                prop.administrative.notesId += 1;
                prop.administrative.notes.put(1, Stables.fromStableNote(note));
                prop.updates.add(#Ok{results = [#ok(?1)]; what = #Note(#Create([arg]))});
            };
        };
        #Ok(Stables.toStableProperty(prop));
    };

    //here we should call to get the arg, and use that id for all ids here
    //we should also pass in property not create a new one each time
    func updateNoteExpectedOutcome(tcase: NoteUpdateCase): UpdateResult {
        let prop = Prop.createBlankProperty();
        let arg : (Types.NoteUArg, [Int]) = switch(tcase){
            case(#NonExistentId) return #Err([(?10, #InvalidElementId)]);
            case(#EmptyTitle) return #Err([(?0, #InvalidData{field = "title"; reason = #EmptyString;})]);
            case(#EmptyContent)  return #Err([(?0, #InvalidData{field = "content"; reason = #EmptyString;})]);
            case(#FutureDate) return #Err([(?0, #InvalidData({ field = "Upload Date"; reason = #CannotBeSetInTheFuture }))]);
            case(#NullContent)({Arg.createNoteUArg() with content = ?"This is a useful note about the property."}, [0]); 
            case(#NullTitle) ({Arg.createNoteUArg() with title = ?"Initial Note"}, [0]);
            case(_){
                TestCases.updateNoteTestCaseArg(tcase);
            };
        };
        let note = Prop.updatedNote(arg);
        prop.administrative.notes.put(0, Stables.fromStableNote(note));
        prop.updates.add(#Ok({results = [#ok(?0)]; what = #Note(#Update(TestCases.updateNoteTestCaseArg(tcase)))}));  
        #Ok(Stables.toStableProperty(prop));
    };
func createInsuranceExpectedOutcome(tcase: InsuranceCreateCase): UpdateResult {
        let prop = Prop.createBlankProperty();
        switch(tcase){
            case(#EmptyPolicyNumber) return makeError(#InvalidData{field = "policy Number"; reason = #EmptyString;});
            case(#EmptyProvider) return makeError(#InvalidData{field = "policy Provider"; reason = #EmptyString;});
            case(#EndDateInPast) return makeError(#InvalidData{field = "Insurance End Date"; reason = #CannotBeSetInThePast;});
            case(#PremiumZero) return makeError(#InvalidData{field = "Insurance Premium"; reason = #CannotBeZero});
            case(#NextPaymentInPast) return makeError(#InvalidData{field = "Next Payment Date"; reason = #CannotBeSetInThePast;});
            case(#EmptyContactInfo) return makeError(#InvalidData{field = "Contact Info"; reason = #EmptyString;});
            case(_){
                let arg = TestCases.createInsuranceTestCaseArg(tcase);
                let insurance = Prop.validInsurancePolicy(1, arg);
                prop.administrative.insuranceId += 1;
                prop.administrative.insurance.put(1, Stables.fromStableInsurancePolicy(insurance));
                prop.updates.add(makeOk(#Insurance(#Create([arg])), true));  
            }
        };
        #Ok(Stables.toStableProperty(prop));
    };

    func updateInsuranceExpectedOutcome(tcase: InsuranceUpdateCase): UpdateResult {
        let prop = Prop.createBlankProperty();
        switch(tcase){
            case(#NonExistentId) return #Err([(?10, #InvalidElementId)]);
            case(#EmptyProvider) return makeError(#InvalidData{field = "policy Provider"; reason = #EmptyString;});
            case(#PremiumZero) return makeError(#InvalidData{field = "Insurance Premium"; reason = #CannotBeZero});
            case(_) {
                let arg = TestCases.updateInsuranceTestCaseArg(tcase);
                let insurance = Prop.updateValidInsurancePolicy(arg);
                prop.administrative.insurance.put(0, Stables.fromStableInsurancePolicy(insurance));
                prop.updates.add(makeOk(#Insurance(#Update(arg)), false)); 
            }
        };
        #Ok(Stables.toStableProperty(prop));
    };

    func createDocumentExpectedOutcome(tcase: DocumentCreateCase): UpdateResult {
        let prop = Prop.createBlankProperty();
        switch(tcase){
            case(#EmptyTitle) return makeError(#InvalidData{field = "title"; reason = #EmptyString;});
            case(#EmptyDescription) return makeError(#InvalidData{field = "description"; reason = #EmptyString;});
            case(#EmptyURL) return makeError(#InvalidData{field = "URL"; reason = #EmptyString;});
            case(_) {
                let arg = TestCases.createDocumentTestCaseArg(tcase);
                let document = Prop.validDocument(1, arg);
                prop.administrative.documentId += 1;
                prop.administrative.documents.put(1, Stables.fromStableDocument(document));
                prop.updates.add(makeOk(#Document(#Create([arg])), true)); 
            }
        };
        #Ok(Stables.toStableProperty(prop));
    };

    func updateDocumentExpectedOutcome(tcase: DocumentUpdateCase): UpdateResult {
        let prop = Prop.createBlankProperty();
        switch(tcase){
            case(#NonExistentId) return #Err([(?10, #InvalidElementId)]);
            case(#EmptyTitle) return makeError(#InvalidData{field = "title"; reason = #EmptyString;});
            case(#EmptyDescription) return makeError(#InvalidData{field = "description"; reason = #EmptyString;});
            case(_) {
                let arg = TestCases.updateDocumentTestCaseArg(tcase);
                let document = Prop.updateValidDocument(arg);
                prop.administrative.documents.put(0, Stables.fromStableDocument(document));
                prop.updates.add(makeOk(#Document(#Update(arg)), false)); 
            }
        };
        #Ok(Stables.toStableProperty(prop));
    };

    func createTenantExpectedOutcome(tcase: TenantCreateCase): UpdateResult {
        let prop = Prop.createBlankProperty();
        switch(tcase) {
            case(#EmptyLeadTenant) return makeError(#InvalidData{field = "lead tenant"; reason = #EmptyString});
            case(#ZeroMonthlyRent) return makeError(#InvalidData{field = "monthly rent"; reason = #CannotBeZero});
            case(#ZeroDeposit) return makeError(#InvalidData{field = "deposit"; reason = #CannotBeZero});
            case(#StartDateInPast) return makeError(#InvalidData{field = "lease start date"; reason = #CannotBeSetInThePast});
            case(_) {
                let arg = TestCases.createTenantTestCaseArg(tcase);
                let tenant = Prop.createValidTenant(arg, 1);
                prop.operational.tenantId += 1;
                prop.operational.tenants.put(1, Stables.fromStableTenant(tenant));
                prop.updates.add(makeOk(#Tenant(#Create([arg])), true)); 
            }
        };
        #Ok(Stables.toStableProperty(prop));
    };

    func updateTenantExpectedOutcome(tcase: TenantUpdateCase): UpdateResult {
        let prop = Prop.createBlankProperty();
        switch(tcase) {
            case(#NonExistentId) return #Err([(?10, #InvalidElementId)]);
            case(#EmptyLeadTenant) return makeError(#InvalidData{field = "lead tenant"; reason = #EmptyString});
            case(#ZeroMonthlyRent) return makeError(#InvalidData{field = "monthly rent"; reason = #CannotBeZero});
            case(#ZeroDeposit) return makeError(#InvalidData{field = "deposit"; reason = #CannotBeZero});
            case(#StartDateInPast) return makeError(#InvalidData{field = "lease start date"; reason = #CannotBeSetInThePast});
            case(_) {
                let arg = TestCases.updateTenantTestCaseArg(tcase);
                let tenant = Prop.updateValidTenant(arg);
                prop.operational.tenants.put(0, Stables.fromStableTenant(tenant));
                prop.updates.add(makeOk(#Tenant(#Update(arg)), false)); 
            }
        };
        #Ok(Stables.toStableProperty(prop));
    };

    func createMaintenanceExpectedOutcome(tcase: MaintenanceCreateCase): UpdateResult {
        let prop = Prop.createBlankProperty();
        switch(tcase) {
            case(#EmptyDescription) return makeError(#InvalidData{field = "description"; reason = #EmptyString});
            case(#DateCompletedInFuture) return makeError(#InvalidData{field = "date completed"; reason = #CannotBeSetInTheFuture});
            case(#DateReportedInFuture) return makeError(#InvalidData{field = "date reported"; reason = #CannotBeSetInTheFuture});
            case(_){
                let arg = TestCases.createMaintenanceTestCaseArg(tcase);
                let maintenance = Prop.createValidMaintenanceRecord(arg, 1);
                prop.operational.maintenanceId += 1;
                prop.operational.maintenance.put(1, Stables.fromStableMaintenanceRecord(maintenance));
                prop.updates.add(makeOk(#Maintenance(#Create([arg])), true)); 
            }
        };
        #Ok(Stables.toStableProperty(prop));
    };

    func updateMaintenanceExpectedOutcome(tcase: MaintenanceUpdateCase): UpdateResult {
        let prop = Prop.createBlankProperty();
        switch(tcase) {
            case(#NonExistentId) return #Err([(?10, #InvalidElementId)]);
            case(#EmptyDescription) return makeError(#InvalidData{field = "description"; reason = #EmptyString});
            case(#DateCompletedInFuture) return makeError(#InvalidData{field = "date completed"; reason = #CannotBeSetInTheFuture});
            case(#DateReportedInFuture) return makeError(#InvalidData{field = "date reported"; reason = #CannotBeSetInTheFuture});
            case(_){
                let arg = TestCases.updateMaintenanceTestCaseArg(tcase);
                let maintenance = Prop.updateValidMaintenanceRecord(arg);
                prop.operational.maintenance.put(0, Stables.fromStableMaintenanceRecord(maintenance));
                prop.updates.add(makeOk(#Maintenance(#Update(arg)), false)); 
            }
        };
        #Ok(Stables.toStableProperty(prop));
    };

    func createImageExpectedOutcome(tcase: ImageCreateCase): UpdateResult {
        let prop = Prop.createBlankProperty();
        switch(tcase) {
            case(#EmptyURL) return makeError(#InvalidData{field = "image"; reason = #EmptyString});
            case(_){
                let arg = TestCases.createImageTestCaseArg(tcase);
                prop.details.misc.imageId += 1;
                prop.details.misc.images.put(1, "initial url to image");
                prop.updates.add(makeOk(#Images(#Create([arg])), true)); 
            }
        };
        #Ok(Stables.toStableProperty(prop));
    };

    func updateImageExpectedOutcome(tcase: ImageUpdateCase): UpdateResult {
        let prop = Prop.createBlankProperty();
        switch(tcase) {
            case(#EmptyURL) return makeError(#InvalidData{field = "image"; reason = #EmptyString});
            case(_){
                let arg = TestCases.updateImageTestCaseArg(tcase);
                prop.details.misc.images.put(0, "updated url to image");
                prop.updates.add(makeOk(#Images(#Update(arg)), false)); 
            }
        };
        #Ok(Stables.toStableProperty(prop));
    };

    func createInspectionExpectedOutcome(tcase: InspectionCreateCase): UpdateResult {
        let prop = Prop.createBlankProperty();
        switch(tcase) {
            case(#EmptyInspectorName) return makeError(#InvalidData{field = "inspector name"; reason = #EmptyString});
            case(#EmptyFindings) return makeError(#InvalidData{field = "findings"; reason = #EmptyString});
            case(#DateInFuture) return makeError(#InvalidData{field = "inspection date"; reason = #CannotBeSetInTheFuture});
            case(_){
                let arg = TestCases.createInspectionTestCaseArg(tcase);
                let inspection = Prop.createValidInspectionRecord(arg, 1);
                prop.operational.inspectionsId += 1;
                prop.operational.inspections.put(1, Stables.fromStableInspectionRecord(inspection));
                prop.updates.add(makeOk(#Inspection(#Create([arg])), true)); 
            }
        };
        #Ok(Stables.toStableProperty(prop));
    };

    func updateInspectionExpectedOutcome(tcase: InspectionUpdateCase): UpdateResult {
        let prop = Prop.createBlankProperty();
        switch(tcase) {
            case(#NonExistentId) return #Err([(?10, #InvalidElementId)]);
            case(#EmptyInspectorName) return makeError(#InvalidData{field = "inspector name"; reason = #EmptyString});
            case(#EmptyFindings) return makeError(#InvalidData{field = "findings"; reason = #EmptyString});
            case(#DateInFuture) return makeError(#InvalidData{field = "inspection date"; reason = #CannotBeSetInTheFuture});
            case(_){
                let arg = TestCases.updateInspectionTestCaseArg(tcase);
                let inspection = Prop.updateValidInspectionRecord(arg);
                prop.operational.inspections.put(0, Stables.fromStableInspectionRecord(inspection));
                prop.updates.add(makeOk(#Inspection(#Update(arg)), false));
            }
        };
        #Ok(Stables.toStableProperty(prop));
    };

    

    func createMonthlyRentExpectedOutcome(tcase: MonthlyRentCreateCase): UpdateResult {
        let prop = Prop.createBlankProperty();
        switch(tcase) {
            case (#Valid) prop.financials.monthlyRent := 1000;
            case (#ZeroRent) return makeErrorNull(#InvalidData{field = "Monthly Rent"; reason = #CannotBeZero});
        };
        prop.updates.add(makeNull(#MonthlyRent(1000)));
        prop.financials.yield := Float.fromInt(12 * prop.financials.monthlyRent) / Float.fromInt(prop.financials.currentValue);
        #Ok(Stables.toStableProperty(prop));
    };

    func createFinancialsExpectedOutcome(tcase: FinancialsCreateCase): UpdateResult {
        let prop = Prop.createBlankProperty();
        let arg = TestCases.createFinancialsTestCaseArg(tcase);
        switch(tcase) {
            case (#Valid) prop.financials.currentValue := arg.currentValue;
            case (#ZeroCurrentValue) return makeErrorNull(#InvalidData{field = "current value"; reason = #CannotBeZero});
        };
        prop.updates.add(makeNull(#Financials(arg)));
        prop.financials.pricePerSqFoot := prop.financials.currentValue / prop.details.physical.squareFootage;
        #Ok(Stables.toStableProperty(prop));
    };

    func createValuationExpectedOutcome(tcase: ValuationCreateCase): UpdateResult {
        let prop = Prop.createBlankProperty();
        switch(tcase) {
            case (#Valid) {
                let arg = TestCases.createValuationTestCaseArg(tcase);
                let valuation = Prop.createValidValuationRecord(arg, 1);
                prop.financials.valuationId += 1;
                prop.financials.valuations.put(1, Stables.fromStableValuationRecord(valuation));
                prop.updates.add(makeOk(#Valuations(#Create([arg])), true));
            };
            case (#ZeroValue) return makeError(#InvalidData{field = "value"; reason = #CannotBeZero});
        };
        #Ok(Stables.toStableProperty(prop));
    };

    func updateValuationExpectedOutcome(tcase: ValuationUpdateCase): UpdateResult {
        let prop = Prop.createBlankProperty();
        switch(tcase) {
            case (#NonExistentId) return #Err([(?10, #InvalidElementId)]);
            case (#ZeroValue) return makeError(#InvalidData{field = "value"; reason = #CannotBeZero});
            case (_){
                let arg = TestCases.updateValuationTestCaseArg(tcase);
                let valuation = Prop.updateValidValuationRecord(arg);
                prop.financials.valuations.put(0, Stables.fromStableValuationRecord(valuation));
                prop.updates.add(makeOk(#Valuations(#Update(arg)), false));
            }
        };
        #Ok(Stables.toStableProperty(prop));
    };

    func createPhysicalDetailsExpectedOutcome(tcase: PhysicalDetailsUpdateCase): UpdateResult {
        let prop = Prop.createBlankProperty();
        switch (tcase) {
            case (#Valid) prop.details.physical := Prop.validUnstablePhysicalDetails();
            case (#RenovationTooOld) return makeErrorNull(#InvalidData{field = "renovation"; reason = #InaccurateData});
            case (#TooManyBeds) return makeErrorNull(#InvalidData{field = "beds"; reason = #InaccurateData});
            case (#TooManyBaths) return makeErrorNull(#InvalidData{field = "baths"; reason = #InaccurateData});
        };
        prop.updates.add(makeNull(#PhysicalDetails(Arg.createPhysicalDetailsUArg())));
        #Ok(Stables.toStableProperty(prop));
    };

    func createAdditionalDetailsExpectedOutcome(tcase: AdditionalDetailsUpdateCase): UpdateResult {
        let prop = Prop.createBlankProperty();
        switch (tcase) {
            case (#Valid) prop.details.additional := Prop.validUnstableAdditionalDetails();
            case (#LowCrimeScore) return makeErrorNull(#InvalidData{field = "Crime Score"; reason = #OutOfRange});
            case (#HighSchoolScore) return makeErrorNull(#InvalidData{field = "School Score"; reason = #OutOfRange});
        };
        prop.updates.add(makeNull(#AdditionalDetails(Arg.createAdditionalDetailsUArg())));
        #Ok(Stables.toStableProperty(prop));
    };

      func createDescriptionExpectedOutcome(tcase: DescriptionCase): UpdateResult {
        let prop = Prop.createBlankProperty();
        switch (tcase) {
            case (#Valid) prop.details.misc.description := TestCases.descriptionTestCaseArg(tcase);
            case (_) return makeErrorNull(#InvalidData({field = "description"; reason = #EmptyString}));
        };
        prop.updates.add(makeNull(#Description(TestCases.descriptionTestCaseArg(tcase))));
        #Ok(Stables.toStableProperty(prop));
    };

//here we should pass in a property not create one
    //use the property id to replace all zeros
    
    func makeError(err: Types.UpdateError): Types.UpdateResult {
        #Err([(?0, err)]);
    };

    func makeErrorNull(err: Types.UpdateError): Types.UpdateResult {
        #Err([(null, err)]);
    };
    //returning updateResult
    //appending result

    func makeOk(what: What, isCreate: Bool): Types.Result {
        #Ok({what; results = [#ok(if(isCreate)?1 else?0)]})
    };

    func makeNull(what: What): Types.Result {
        #Ok({what; results = [#ok(null)]})
    };

    
    type What = Types.What;
    func deleteEntries(what: What, property: PropertyUnstable): (){
        switch(what){
            case(#Insurance(_)) property.administrative.insurance.delete(0);
            case(#Document(_)) property.administrative.documents.delete(0);
            case(#Note(_)) property.administrative.notes.delete(0);
            case(#Maintenance(_)) property.operational.maintenance.delete(0);
            case(#Inspection(_)) property.operational.inspections.delete(0);
            case(#Tenant(_)) property.operational.tenants.delete(0);
            case(#Valuations(_)) property.financials.valuations.delete(0);
            case(#Images(_)) property.details.misc.images.delete(0);
            case(_){};
        }
    };



    func deleteCaseExpectedOutcome(tcase: DeleteCase, what: What): UpdateResult {
        let prop = Prop.createBlankProperty();
        switch(tcase){
            case(#Valid) deleteEntries(what, prop);
            case(#NonExistentId) return #Err([(?10, #InvalidElementId)]);
        };
        prop.updates.add(makeOk(what, false));
        #Ok(Stables.toStableProperty(prop));
    };

     public func createNoteTestCaseArg(tcase: NoteCreateCase, prop: Types.Property): NoteCArg {
        let arg = Arg.createNoteCArg();
        switch(tcase){
            case(#Valid or #AnonymousAuthor) arg;
            case(#EmptyTitle) return {arg with title = ""};
            case(#EmptyContent) return {arg with content = ""};
            case(#FutureDate) return {arg with date = ?Utils.daysInFuture(7)};
        };
    };

    public func updateNoteTestCaseArg(tcase: NoteUpdateCase, prop: Types.Property): (NoteUArg, [Int]) {
        let arg = Arg.createNoteUArg();
        switch(tcase){
            case(#Valid) (arg, [0]);
            case(#NonExistentId) (arg, [10]);
            case(#EmptyTitle) ({arg with title = ?""}, [0]);
            case(#NullTitle) ({arg with title = null}, [0]);
            case(#EmptyContent) ({arg with content = ?""}, [0]);
            case(#NullContent) ({arg with content = null}, [0]);
            case(#FutureDate) ({arg with date = ?Utils.daysInFuture(7)}, [0]);
        }
    };

    public func createInsuranceTestCaseArg(tcase: InsuranceCreateCase): InsurancePolicyCArg {
        let arg = Arg.createInsurancePolicyCArg();
        switch(tcase){
            case(#Valid) arg;
            case(#EmptyPolicyNumber) return { arg with policyNumber = "" };
            case(#EmptyProvider) return { arg with provider = "" };
            case(#EndDateInPast) return { arg with endDate = ?(Time.now() - 1_000_000) };
            case(#PremiumZero) return { arg with premium = 0 };
            case(#NextPaymentInPast) return { arg with nextPaymentDate = Time.now() - 1_000_000 };
            case(#EmptyContactInfo) return { arg with contactInfo = "" };
        };
    };

    public func updateInsuranceTestCaseArg(tcase: InsuranceUpdateCase): (InsurancePolicyUArg, [Int]) {
        let arg = Arg.createInsurancePolicyUArg();
        switch(tcase){
            case(#Valid) (arg, [0]);
            case(#NonExistentId) (arg, [10]);
            case(#EmptyProvider) return ({ arg with provider = ?"" }, [0]);
            case(#PremiumZero) return ({ arg with premium = ?0 }, [0]);
        };
    };

    public func createDocumentTestCaseArg(tcase: DocumentCreateCase): DocumentCArg {
        let arg = Arg.createDocumentCArg();
        switch(tcase){
            case(#Valid) arg;
            case(#EmptyTitle) return { arg with title = "" };
            case(#EmptyDescription) return { arg with description = "" };
            case(#EmptyURL) return { arg with url = "" };
        };
    };
    
    public func updateDocumentTestCaseArg(tcase: DocumentUpdateCase): (DocumentUArg, [Int]) {
        let arg = Arg.createDocumentUArg();
        switch(tcase){
            case(#Valid) (arg, [0]);
            case(#NonExistentId) (arg, [10]);
            case(#EmptyTitle) ({ arg with title = ?"" }, [0]);
            case(#EmptyDescription) ({ arg with description = ?"" }, [0]);
        };
    };


    // Tenant
    

    // Maintenance
    public func createMaintenanceTestCaseArg(tcase: MaintenanceCreateCase): MaintenanceRecordCArg {
        let arg = Arg.createMaintenanceRecordCArg();
        switch (tcase) {
            case (#Valid) arg;
            case (#EmptyDescription) return { arg with description = "" };
            case (#DateCompletedInFuture) return { arg with dateCompleted = ?(Time.now() + 1_000_000_000) };
            case (#DateReportedInFuture) return { arg with dateReported = ?(Time.now() + 1_000_000_000) };
        };
    };

    public func updateMaintenanceTestCaseArg(tcase: MaintenanceUpdateCase): (MaintenanceRecordUArg, [Int]) {
        let arg = Arg.createMaintenanceRecordUArg();
        switch (tcase) {
            case (#Valid) (arg, [0]);
            case (#NonExistentId) (arg, [10]);
            case (#EmptyDescription) ({ arg with description = ?"" }, [0]);
            case (#DateCompletedInFuture) ({ arg with dateCompleted = ?(Time.now() + 1_000_000_000_000) }, [0]);
            case (#DateReportedInFuture) ({ arg with dateReported = ?(Time.now() + 1_000_000_000_000) }, [0]);
        };
    };

    // Inspection
    public func createInspectionTestCaseArg(tcase: InspectionCreateCase): InspectionRecordCArg {
        let arg = Arg.createInspectionRecordCArg();
        switch (tcase) {
            case (#Valid) arg;
            case (#EmptyInspectorName) return { arg with inspectorName = "" };
            case (#EmptyFindings) return { arg with findings = "" };
            case (#DateInFuture) return { arg with date = ?(Time.now() + 1) };
        };
    };

    public func updateInspectionTestCaseArg(tcase: InspectionUpdateCase): (InspectionRecordUArg, [Int]) {
        let arg = Arg.createInspectionRecordUArg();
        switch (tcase) {
            case (#Valid) (arg, [0]);
            case (#NonExistentId) (arg, [10]);
            case (#EmptyInspectorName) ({ arg with inspectorName = ?"" }, [0]);
            case (#EmptyFindings) ({ arg with findings = ?"" }, [0]);
            case (#DateInFuture) ({ arg with date = ?(Time.now() + 1) }, [0]);
        };
    };

    public func createMonthlyRentTestCaseArg(tcase: MonthlyRentCreateCase): Nat {
        switch (tcase) {
            case (#Valid) 1000;
            case (#ZeroRent) 0;
        };
    };

    public func createFinancialsTestCaseArg(tcase: FinancialsCreateCase): FinancialsArg {
        let arg = Arg.createFinancialsArg();
        switch (tcase) {
            case (#Valid) arg;
            case (#ZeroCurrentValue) return { arg with currentValue = 0 };
        };
    };

    public func createValuationTestCaseArg(tcase: ValuationCreateCase): ValuationRecordCArg {
        let arg = Arg.createValuationRecordCArg();
        switch (tcase) {
            case (#Valid) arg;
            case (#ZeroValue) return { arg with value = 0 };
        };
    };

    public func updateValuationTestCaseArg(tcase: ValuationUpdateCase): (ValuationRecordUArg, [Int]) {
        let arg = Arg.createValuationRecordUArg();
        switch (tcase) {
            case (#Valid) (arg, [0]);
            case (#NonExistentId) (arg, [10]);
            case (#ZeroValue) ({ arg with value = ?0 }, [0]);
        };
    };

    public func createPhysicalDetailsTestCaseArg(tcase: PhysicalDetailsUpdateCase): Types.PhysicalDetailsUArg {
        let arg = Arg.createPhysicalDetailsUArg();
        switch (tcase) {
            case (#Valid) arg;
            case (#RenovationTooOld) return { arg with lastRenovation = ?1890 };
            case (#TooManyBeds) return { arg with beds = ?11 };
            case (#TooManyBaths) return { arg with baths = ?11 };
        };
    };

    public func createAdditionalDetailsTestCaseArg(tcase: AdditionalDetailsUpdateCase): Types.AdditionalDetailsUArg {
        let arg = Arg.createAdditionalDetailsUArg();
        switch (tcase) {
            case (#Valid) arg;
            case (#LowCrimeScore) return { arg with crimeScore = ?10 };
            case (#HighSchoolScore) return { arg with schoolScore = ?11 };
        };
    };

    type ImageCreateCase = TestTypes.ImageCreateCase;
    type ImageUpdateCase = TestTypes.ImageUpdateCase;
    type DescriptionCase = TestTypes.DescriptionCase;
    public func createImageTestCaseArg(tcase: ImageCreateCase): Text {
        switch (tcase) {
            case (#Valid) "initial url to image";
            case (#EmptyURL) "";
        };
    };

    public func updateImageTestCaseArg(tcase: ImageUpdateCase): (Text, [Int]) {
        switch (tcase) {
            case (#Valid) ("updated url to image",[0]);
            case (#EmptyURL) ("",[0]);
        };
    };

    public func descriptionTestCaseArg(tcase: DescriptionCase): Text {
        switch (tcase) {
            case (#Valid) "updated description of property";
            case (#Empty) "";
        };
    };


results diagnosis
notes = [(0, {author = vq2za-kqaaa-aaaas-amlvq-cai; content = "Updated content for note."; date = ?(+1_754_994_648_898_256_931); id = 0; title = "Initial Note"})]; notesId = 0
 notes = [(0, {author = vq2za-kqaaa-aaaas-amlvq-cai; content = "Updated content for note."; date = ?(+1_754_994_648_898_256_931); id = 0; title = "Initial Note"})]; notesId = 0
[#Ok({results = [#ok(?0)]; what = #Note(#Update({content = ?"Updated content for note."; date = ?(+1_754_994_648_898_256_931); title = null}, [0]))})]
[#Ok({results = [#ok(?0)]; what = #Note(#Update({content = ?"Updated content for note."; date = ?(+1_754_994_648_898_256_931); title = ?"Initial Note"}, [0])

notes = [(0, {author = vq2za-kqaaa-aaaas-amlvq-cai; content = "Updated content for note."; date = ?(+1_754_998_555_170_279_279); id = 0; title = "Updated Note Title"})]; notesId = 0};
updates = [#Ok({results = [#ok(?0)]; what = #Note(#Update({content = ?"Updated content for note."; date = ?(+1_754_998_555_170_279_279); title = ?"Updated Note Title"}, [0]))}), #Ok({results = [#ok(?0)]; what = #Note(#Update({content = ?"Updated content for note."; date = ?(+1_754_998_555_170_279_279); title = null}, [0]))})]}
notes = [(0, {author = vq2za-kqaaa-aaaas-amlvq-cai; content = "Updated content for note."; date = ?(+1_754_998_555_170_279_279); id = 0; title = "Updated Note Title"})]; notesId = 0};
updates = [#Ok({results = [#ok(?0)]; what = #Note(#Update({content = ?"Updated content for note."; date = ?(+1_754_998_555_170_279_279); title = ?"Updated Note Title"}, [0]))}), #Ok({results = [#ok(?0)]; what = #Note(#Update({content = ?"Updated content for note."; date = ?(+1_754_998_555_170_279_279); title = ?"Updated Note Title"}, [0]))})]}