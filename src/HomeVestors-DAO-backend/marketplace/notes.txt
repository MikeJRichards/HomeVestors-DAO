    public type Handler<Id, T, StableT> = {
        validateAndPrepare() -> [(Id, Result.Result<T, Types.UpdateError>)];
        asyncEffect: [(Id, Result.Result<T, Types.UpdateError>)] -> async [(Id, Result.Result<(), UpdateError>)];
        applyAsyncEffects: ([(Id, Result.Result<T, Types.UpdateError>)], [(Id, Result.Result<(), UpdateError>)]) -> [(Id, Result.Result<StableT, Types.UpdateError>)];
        applyUpdate: (Id, StableT) -> Id;
        getUpdate: () -> Update;
    };

    public type crudHandler<C, U, T, StableT> = {
        map: HashMap.HashMap<Nat, StableT>;
        id: {var value: Nat};
        assignId: (Nat, StableT) -> (Nat, StableT); //increment property id, assign id to el, return (id, el)
        delete: (Nat, StableT) -> ();
        fromStable: StableT -> T;
        create: (C, Nat) -> T;
        mutate: (U, T) -> T;
        validate: ?T -> Result.Result<T, UpdateError>;
    };

    public type Handler<R1, T, StableT> = {
        validateAndPrepare() -> R1;
        asyncEffect: R1 -> async R2;
        applyAsyncEffects: (R1, R2) -> R1; //but this is wrong cause StableT vs T
        applyUpdate: (Nat, StableT) -> Nat;
        getUpdate: () -> Update; //also increments id on create
    };


  


Action Type
 public type Actions<C, U> = {
        #Create: [{arg: C; quantity: ?Nat}];
        #Update: U;
        #Delete: [Int];
    };

type Proposal = {
  proposalId: Nat;

  title: ?Text;
  description: ?Text;
  creator: Principal;
  createdAt: Time;
  eligibleVoters: [Principal];
  totalEligibleVoters: Nat;            // ← stored for convenience
  votes: [(Principal, Bool)];          // One vote per principal
  status: ProposalStatus;               // Draft | Live | Executed | Rejected

  category: ?ProposalCategory;
  implementation: ?ImplementationCategory;
  actions: [What];
};

type ProposalCategory =
  #Invoice { invoiceId: Nat } |
  #RentPolicy |
  #Maintenance |
  #Valuation |
  #Other(Text);

type ImplementationCategory =
  #Quick |     // 6 hours
  #Day |       // 24 hours
  #FourDays |
  #Week |
  #BiWeek |
  #Month;


type LiveProposalArgs = {
    endTime: Time;
    yesVotes: Nat;
    noVotes: Nat;
    eligibleVoterCount: Nat;
    totalVotesCast: Nat;                 // ← explicit for analytics / UI
    timerId: ?Nat;
};

type ExecutedProposalArgs = {
    outcome: Bool;              // true = passed, false = rejected
    executedAt: Time;
    yesVotes: Nat;
    totalVotesCast: Nat;                 // ← explicit for analytics / UI
    noVotes: Nat;
};

type ProposalStatus = {
  #LiveProposal: LiveProposalArgs;
  #Executed: ExecutedProposalArgs;
  #Draft;
  #RejectedEarly { reason: Text };
};

type CreateProposalArg = {
  title: Text;
  description: Text;
  category: ProposalCategory;
  implementation: ImplementationCategory;

  actions: [What];                      // The proposed mutations
};

type UpdateProposalArg = {
  title: ?Text;
  description: ?Text;
  category: ?ProposalCategory;
  implementation: ?ImplementationCategory;
  actions: ?[What];
};

type Governance = {
    proposalIdCounter: Nat;
    proposals: [(Nat, Proposal)];
    assetCost: AcceptedCryptos;
    proposalCost: Nat;              // in e8s or base units
    requireNftToPropose: Bool;      // must own an NFT from this property to propose
    minYesVotes: Nat;           // Absolute vote count threshold
    minTurnout: Nat;               // % turnout requirement
    quorumPercentage: Nat;         // e.g. 51
};



////////////////////
/////Invoices
/////////////////////

type Invoice = {
  invoiceId: Nat;
  status: InvoiceStatus;
  category: InvoiceCategory;

  direction: InvoiceDirection;           // ← #Incoming | #Outgoing
  payer: ?Principal;                     // ← Only used for #Incoming

  title: Text;
  description: Text;
  amount: Nat;
  dateIssued: Time;
  dueDate: Time;

  paymentStatus: PaymentStatus;
  paymentMethod: ?PaymentMethod;
  datePaid: ?Time;

  recurrence: RecurrenceType;

  proposalId: ?Nat;                      // ← Only for outgoing invoices
  logs: [InvoiceLog];
};

type InvoiceDirection = {
    #Incoming: Account; //the account sending tokens to dao
    #Outgoing:Account; //the account that is recieving tokens from dao
};

type InvoiceStatus = 
  #Draft | #Pending | #Approved | #Rejected | #Paid | #Failed | #PreApproved(Principal);

type PaymentStatus = 
  #WaitingApproval | #Pending | #Confirmed { transactionId: ?Text } | #Failed;

type PaymentMethod = 
  #ICP | #HGB | #CKUSDC | #Other(Text);

type RecurrenceType = {
  period: PeriodicRecurrence;
  endDate: ?Time;
  previousInvoiceIds: [Nat];
  count: Nat;
};

type PeriodicRecurrence = 
  #None | #Daily | #Weekly | #Monthly | #Quarterly | #BiAnnually | #Annually | #Custom { interval: Nat };

type InvoiceLog = {
  timestamp: Time;
  changedBy: Account;
  actionType: InvoiceLogAction;
  details: ?Text;
};

type CreateInvoiceArg = {
  title: Text;
  description: Text;
  amount: Nat;
  dueDate: Time;

  category: InvoiceCategory;

  direction: InvoiceDirection;             // #Incoming(Account) or #Outgoing(Account)

  recurrence: RecurrenceType;             // Can be #None
  paymentMethod: ?PaymentMethod;          // Optional: CKUSDC, HGB, etc.

  preApprovedByAdmin: Bool;               // If true: skip DAO proposal, mark as PreApproved
};

type UpdateInvoiceArg = {
  invoiceId: Nat;

  title: ?Text;
  description: ?Text;
  amount: ?Nat;
  dueDate: ?Time;
  category: ?InvoiceCategory;

  paymentMethod: ?PaymentMethod;
  recurrence: ?RecurrenceType;
};



Okay invoice lifecycle
create - creates Draft
mutate either updates a draft to pending, or leaves in draft depending on process field in U arg
delete - takes a pending invoice and either preApproves it and sets up payment if caller = admin or finds associated proposal if outgoing, if proposal accpeted becomes approved and creates timer to attempt payment - paid/failed. If rejected proposal - becomes rejected invoice
